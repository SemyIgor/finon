// show / hide 

.d-none,
.hidden {
	display: none !important;
}

.hide {
	@include fade("hide");
}

.visually-hidden {
	position: absolute;
	width: 1px;
	height: 1px;
	margin: -1px;
	border: 0;
	padding: 0;
	white-space: nowrap;
	clip-path: inset(100%);
	clip: rect(0 0 0 0);
	overflow: hidden;
}

// overflow 

.overflow-hidden,
.no-scroll {
	overflow: hidden;
}

.no-scroll-x {
	overflow-x: hidden;
}

.no-scroll-y {
	overflow-y: hidden;
}

// text

.text {
	&-left {
		text-align: left;
	}

	&-right {
		text-align: right;
	}

	&-center {
		text-align: center;
	}

	&-justify {
		text-align: justify;
	}

	&-initial {
		text-align: initial;
	}

	&-inherit {
		text-align: inherit;
	}
}

// flex 

.flex {
	display: flex;

	&-row {
		flex-direction: row;
	}

	&-col {
		flex-direction: column;
	}

	&-wrap {
		flex-wrap: wrap;
	}

	&-justify {
		&-start {
			justify-content: flex-start;
		}

		&-end {
			justify-content: flex-end;
		}

		&-center {
			justify-content: center;
		}

		&-between {
			justify-content: space-between;
		}

		&-around {
			justify-content: space-around;
		}

		&-evenly {
			justify-content: space-evenly;
		}
	}

	&-items {
		&-start {
			align-items: flex-start;
		}

		&-end {
			align-items: flex-end;
		}

		&-center {
			align-items: center;
		}

		&-baseline {
			align-items: baseline;
		}

		&-stretch {
			align-items: stretch;
		}
	}

	&-self {
		&-start {
			align-self: flex-start;
		}

		&-end {
			align-self: flex-end;
		}

		&-center {
			align-self: center;
		}

		&-stretch {
			align-self: stretch;
		}
	}

	&-grow {
		flex-grow: 1;
	}

	&-shrink {
		flex-shrink: 1;
	}

	// flex-1: Этот класс устанавливает свойство flex-grow равным 1, что означает, что элемент будет занимать всю доступную для него дополнительную свободную область на главной оси flex-контейнера. Он растягивает элемент так, чтобы он занимал все доступное пространство.
	&-1 {
		flex: 1;
	}

	// flex-auto: Этот класс устанавливает свойство flex равным 1 1 auto. Это означает, что элемент будет растягиваться на всю доступную ему ширину, но не будет сжиматься, чтобы соответствовать содержимому. Также, если у вас есть несколько элементов с flex-auto, они будут равномерно распределять доступное пространство на основе своих содержимых.
	&-auto {
		flex: auto;
	}
}


// error 

.error-text {
	color: red;
}

// font

.font {

	&-100,
	&-thin {
		font-weight: 100;
	}

	&-200,
	&-extra-light {
		font-weight: 200;
	}

	&-300,
	&-light {
		font-weight: 300;
	}

	&-400,
	&-normal {
		font-weight: 400;
	}

	&-500,
	&-medium {
		font-weight: 500;
	}

	&-600,
	&-semibold {
		font-weight: 600;
	}

	&-700,
	&-bold {
		font-weight: 700;
	}

	&-800,
	&-extra-bold {
		font-weight: 800;
	}

	&-900,
	&-black {
		font-weight: 900;
	}
}

// reset

.padding-reset {
	padding: 0;
}

.margin-reset {
	margin: 0;
}

.padding-margin-reset {
	padding: 0;
	margin: 0;
}